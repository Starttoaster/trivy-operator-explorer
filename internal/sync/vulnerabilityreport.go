package sync

import (
	"fmt"
	"strings"
	"time"

	"github.com/aquasecurity/trivy-operator/pkg/apis/aquasecurity/v1alpha1"
	"github.com/jmoiron/sqlx"
	"github.com/starttoaster/trivy-operator-explorer/internal/db"
	"github.com/starttoaster/trivy-operator-explorer/internal/kube"
	log "github.com/starttoaster/trivy-operator-explorer/internal/logger"
)

// VulnerabilityReports is the main sync job for the VulnerabilityReport kind
func VulnerabilityReports() {
	firstRun := true
	cleanupCounter := 0
	const cleanupInterval = 10

	for {
		if !firstRun {
			time.Sleep(5 * time.Minute)
		}
		firstRun = false

		list, err := kube.GetVulnerabilityReportList()
		if err != nil {
			log.Logger.Error("error fetching vulnerability report list for sync", "error", err)
			continue
		}

		if list != nil {
			syncedCount := 0
			errorCount := 0

			// Each report is specific to an image found in a particular kube resource (statefulset/replicaset/etc) and namespace
			for _, report := range list.Items {
				data := parseReport(report)

				err = syncImage(data)
				if err != nil {
					log.Logger.Error("error syncing image", "error", err)
					errorCount++
					continue
				}
				syncedCount++
			}

			log.Logger.Info("vulnerability report sync completed",
				"total_reports", len(list.Items),
				"synced", syncedCount,
				"errors", errorCount)

			// Run cleanup periodically
			cleanupCounter++
			if cleanupCounter >= cleanupInterval {
				log.Logger.Info("starting periodic cleanup of orphaned data")
				err = cleanupOrphanedData(list.Items)
				if err != nil {
					log.Logger.Error("error during cleanup", "error", err)
				} else {
					log.Logger.Info("periodic cleanup completed successfully")
				}
				cleanupCounter = 0 // Reset counter
			}
		}
	}
}

func syncImage(data parsedReport) error {
	tx, err := db.Client.Beginx()
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	imageID, err := insertOrGetImage(tx, data)
	if err != nil {
		return fmt.Errorf("failed to insert/get image: %w", err)
	}

	resourceID, err := insertOrGetResource(tx, data)
	if err != nil {
		return fmt.Errorf("failed to insert/get resource: %w", err)
	}

	err = createImageResourceRelation(tx, imageID, resourceID)
	if err != nil {
		return fmt.Errorf("failed to create image-resource relation: %w", err)
	}

	err = tx.Commit()
	if err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// insertOrGetImage inserts a new image or returns the ID of an existing one
func insertOrGetImage(tx *sqlx.Tx, data parsedReport) (int64, error) {
	// Try to insert the image (ignore if it already exists due to UNIQUE constraint)
	result, err := tx.Exec(
		"INSERT OR IGNORE INTO images (registry, repository, tag, sha, os, eosl) VALUES (?, ?, ?, ?, ?, ?)",
		data.Registry, data.Repository, data.Tag, data.Digest, data.OS, data.EndOfServiceLife)
	if err != nil {
		return 0, err
	}

	// Check if a new row was inserted
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	var imageID int64
	if rowsAffected > 0 {
		// New row was inserted, get the ID
		imageID, err = result.LastInsertId()
		if err != nil {
			return 0, err
		}
	} else {
		// Row already exists, get the existing ID
		err = tx.Get(&imageID,
			"SELECT id FROM images WHERE registry = ? AND repository = ? AND tag = ? AND sha = ?",
			data.Registry, data.Repository, data.Tag, data.Digest)
		if err != nil {
			return 0, err
		}
	}

	return imageID, nil
}

// insertOrGetResource inserts a new resource or returns the ID of an existing one
func insertOrGetResource(tx *sqlx.Tx, data parsedReport) (int64, error) {
	// Resource doesn't exist, insert it
	result, err := tx.Exec(
		"INSERT OR IGNORE INTO images_resources (name, namespace, kind) VALUES (?, ?, ?)",
		data.ResourceName, data.ResourceNamespace, data.ResourceKind)
	if err != nil {
		return 0, err
	}

	// Check if a new row was inserted
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return 0, err
	}

	var resourceID int64
	if rowsAffected > 0 {
		// New row was inserted, get the ID
		resourceID, err = result.LastInsertId()
		if err != nil {
			return 0, err
		}
	} else {
		// Row already exists, get the existing ID
		err = tx.Get(&resourceID,
			"SELECT id FROM images_resources WHERE name = ? AND namespace = ? AND kind = ?",
			data.ResourceName, data.ResourceNamespace, data.ResourceKind)
		if err != nil {
			return 0, err
		}
	}
	return resourceID, nil
}

// createImageResourceRelation creates a relationship between image and resource if it doesn't exist
func createImageResourceRelation(tx *sqlx.Tx, imageID, resourceID int64) error {
	_, err := tx.Exec("INSERT OR IGNORE INTO images_resources_relations (image_id, resource_id) VALUES (?, ?)", imageID, resourceID)
	if err != nil {
		return err
	}
	return nil
}

// cleanupOrphanedData removes images, resources, and relationships that no longer have corresponding vulnerability reports
func cleanupOrphanedData(currentReports []v1alpha1.VulnerabilityReport) error {
	tx, err := db.Client.Beginx()
	if err != nil {
		return fmt.Errorf("failed to begin cleanup transaction: %w", err)
	}
	defer tx.Rollback()

	// Create a map of currently active image identifiers for quick lookup
	activeImages := make(map[string]bool)
	for _, report := range currentReports {
		data := parseReport(report)
		imageKey := fmt.Sprintf("%s|%s|%s|%s", data.Registry, data.Repository, data.Tag, data.Digest)
		activeImages[imageKey] = true
	}

	// Get all images from the database
	var allImages []struct {
		ID         int64  `db:"id"`
		Registry   string `db:"registry"`
		Repository string `db:"repository"`
		Tag        string `db:"tag"`
		Sha        string `db:"sha"`
	}
	err = tx.Select(&allImages, "SELECT id, registry, repository, tag, sha FROM images")
	if err != nil {
		return fmt.Errorf("failed to fetch all images: %w", err)
	}

	// Find orphaned images
	var orphanedImageIDs []int64
	for _, image := range allImages {
		imageKey := fmt.Sprintf("%s|%s|%s|%s", image.Registry, image.Repository, image.Tag, image.Sha)
		if !activeImages[imageKey] {
			orphanedImageIDs = append(orphanedImageIDs, image.ID)
		}
	}

	// Delete orphaned image-resource relationships first (due to foreign key constraints)
	if len(orphanedImageIDs) > 0 {
		query, args, err := sqlx.In("DELETE FROM images_resources_relations WHERE image_id IN (?)", orphanedImageIDs)
		if err != nil {
			return fmt.Errorf("failed to build delete query for relationships: %w", err)
		}
		query = tx.Rebind(query)

		result, err := tx.Exec(query, args...)
		if err != nil {
			return fmt.Errorf("failed to delete orphaned relationships: %w", err)
		}

		relationshipsDeleted, _ := result.RowsAffected()
		log.Logger.Info("deleted orphaned image-resource relationships", "count", relationshipsDeleted)
	}

	// Delete orphaned images
	if len(orphanedImageIDs) > 0 {
		query, args, err := sqlx.In("DELETE FROM images WHERE id IN (?)", orphanedImageIDs)
		if err != nil {
			return fmt.Errorf("failed to build delete query for images: %w", err)
		}
		query = tx.Rebind(query)

		result, err := tx.Exec(query, args...)
		if err != nil {
			return fmt.Errorf("failed to delete orphaned images: %w", err)
		}

		imagesDeleted, _ := result.RowsAffected()
		log.Logger.Info("deleted orphaned images", "count", imagesDeleted)
	}

	// Clean up orphaned resources (resources that are no longer referenced by any image)
	_, err = tx.Exec(`
		DELETE FROM images_resources 
		WHERE id NOT IN (
			SELECT DISTINCT resource_id 
			FROM images_resources_relations
		)
	`)
	if err != nil {
		return fmt.Errorf("failed to delete orphaned resources: %w", err)
	}

	// Get count of orphaned resources deleted
	var orphanedResourcesCount int
	err = tx.Get(&orphanedResourcesCount, `
		SELECT COUNT(*) FROM images_resources 
		WHERE id NOT IN (
			SELECT DISTINCT resource_id 
			FROM images_resources_relations
		)
	`)
	if err == nil && orphanedResourcesCount > 0 {
		log.Logger.Info("deleted orphaned resources", "count", orphanedResourcesCount)
	}

	// Commit the transaction
	err = tx.Commit()
	if err != nil {
		return fmt.Errorf("failed to commit cleanup transaction: %w", err)
	}

	log.Logger.Info("cleanup completed successfully",
		"orphaned_images", len(orphanedImageIDs),
		"active_images", len(activeImages))

	return nil
}

/*
//
// Report Parsing Logic
//
*/

type parsedReport struct {
	// Image details
	Registry         string
	Repository       string
	Tag              string
	Digest           string
	OS               string
	EndOfServiceLife bool

	// Resource details
	ResourceName      string
	ResourceNamespace string
	ResourceKind      string
}

func parseReport(report v1alpha1.VulnerabilityReport) parsedReport {
	data := parsedReport{
		Registry:         report.Report.Registry.Server,
		Repository:       report.Report.Artifact.Repository,
		Tag:              report.Report.Artifact.Tag,
		Digest:           report.Report.Artifact.Digest,
		OS:               parseImageOS(report.Report),
		EndOfServiceLife: report.Report.OS.Eosl,

		ResourceName:      report.ObjectMeta.Labels["trivy-operator.resource.name"],
		ResourceNamespace: report.ObjectMeta.Labels["trivy-operator.resource.namespace"],
		ResourceKind:      report.ObjectMeta.Labels["trivy-operator.resource.kind"],
	}

	return data
}

func parseImageOS(report v1alpha1.VulnerabilityReportData) string {
	data := fmt.Sprintf("%s %s", report.OS.Family, report.OS.Name)
	data = strings.TrimPrefix(data, " ")
	data = strings.TrimSuffix(data, " ")
	return data
}
